<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Game Solver — Pure HTML/CSS/JS (Palette + Counts)</title>
  <style>
    html, body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:#0b0c10; color:#e6edf3; }
    .wrap { max-width: 1120px; margin: 32px auto; padding: 0 16px; }
    .row { display: flex; gap: 16px; align-items: center; flex-wrap: wrap; }
    .panel { background: #11151a; border: 1px solid #1f2937; border-radius: 14px; padding: 16px; box-shadow: 0 8px 30px rgba(0,0,0,.25); }
    .panel h2 { margin: 0 0 8px; font-size: 16px; opacity:.9; }
    button { background: #2b6cb0; color: #fff; border: 0; border-radius: 12px; padding: 10px 14px; cursor: pointer; font-weight: 600; }
    button.secondary { background: #334155; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    input, select { background:#0b1220; color:#e6edf3; border:1px solid #1f2937; border-radius:10px; padding: 8px 10px; }
    label { font-size: 13px; opacity:.9; }
    canvas { background: #0b1220; border: 1px solid #1f2937; border-radius: 12px; image-rendering: pixelated; }
    .legend { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    .swatch { width: 24px; height: 24px; border-radius:6px; border:1px solid #1f2937; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; position: relative; }
    .badge { position:absolute; bottom:-8px; right:-8px; background:#0b1220; border:1px solid #1f2937; border-radius:999px; padding:1px 6px; font-size:11px; }
    .swatch.active { outline:2px solid #3b82f6; }
    .log { white-space: pre-wrap; background:#0b1220; border:1px solid #1f2937; border-radius:12px; padding:12px; min-height: 160px; }
    .col { display:flex; flex-direction: column; gap: 8px; }
    .muted { opacity: .7; }
    .status { font-size: 12px; opacity: .8; }
    .pill { border:1px solid #1f2937; border-radius: 999px; padding:2px 8px; background:#0b1220; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Game Solver (pure frontend: HTML + CSS + JS)</h1>
    <p class="muted">M × N tubes (stacks). Typically M=4 height, N≈14 tubes, with N−2 full and N−2 colors total. Default undo chances: 5.</p>

    <div class="row">
      <div class="panel" style="flex: 1 1 560px;">
        <h2>Board</h2>
        <div class="row">
          <label>Columns <input id="cols" type="number" value="14" min="2" max="24"></label>
          <label>Height <input id="rows" type="number" value="4" min="2" max="12"></label>
          <label>Cell size <input id="cellsize" type="number" value="36" min="16" max="48"></label>
          <label>Mode
            <select id="mode">
              <option value="0">Normal (combo allowed)</option>
              <option value="1">No combo move</option>
              <option value="2">Queue output (FIFO)</option>
            </select>
          </label>
          <label>Undo chances <input id="undo" type="number" value="5" min="0" max="20"></label>
          <button id="reset">Reset</button>
          <button id="rand">Randomize</button>
        </div>
        <div style="margin-top:10px"><canvas id="grid" width="300" height="300"></canvas></div>

        <div class="panel" style="margin-top:12px">
          <h2 style="display:flex;align-items:center;gap:8px">Palette <span class="muted" id="paletteHint">(click to select; left‑click paints, right‑click erases)</span></h2>
          <div class="row" style="align-items:flex-end; gap: 12px;">
            <div class="legend" id="palette"></div>
            <div class="row">
              <label>Colors <input id="numcolors" type="number" value="12" min="1" max="20"></label>
              <button id="rebuildPalette" class="secondary">Rebuild</button>
            </div>
          </div>
          <div class="pill" style="margin-top:8px">Each swatch shows its <b>remaining</b> pieces to place. Painting decrements; erasing increments.</div>
        </div>
      </div>

      <div class="panel" style="flex: 1 1 420px;">
        <h2>Controls</h2>
        <div class="row">
          <button id="solve">Solve</button>
          <button id="step" class="secondary">Apply next step to board</button>
          <button id="clear" class="secondary">Clear steps</button>
          <button id="runtests" class="secondary">Run self‑tests</button>
        </div>
        <div class="col" style="margin-top:12px">
          <div class="status" id="status">Ready. Pure JS; no Python.</div>
          <label>Steps</label>
          <div id="steps" class="log"></div>
        </div>
      </div>
    </div>

    <div class="panel" style="margin-top:16px">
      <h2>Notes</h2>
      <ul>
        <li>Left‑click on the board = paint with the <b>selected palette color</b>. Right‑click = erase to <b>EMPTY</b>.</li>
        <li>Unknown blocks are now <b>disabled</b> in the editor (as requested). Solver still supports them internally if needed.</li>
        <li>Groups (columns) are stored <em>bottom-to-top</em> in memory and drawn that way.</li>
        <li>Modes:
          <ul>
            <li><b>Normal</b>: move a top segment of same-color blocks at once (combo).</li>
            <li><b>No combo</b>: move only a single block at a time.</li>
            <li><b>Queue</b>: move from the bottom (FIFO) instead of top (LIFO).</li>
          </ul>
        </li>
      </ul>
    </div>
  </div>

  <script>
    // ----------------- Data model & solver (pure JS) -----------------
    const NodeType = Object.freeze({ UNKNOWN:'?', UNK_REVEALED:'!', KNOWN:'.', EMPTY:'_' });
    const GameMode = Object.freeze({ NORMAL:0, NO_COMBO:1, QUEUE:2 });

    class GameNode { constructor(type, pos, color=null){ this.type=type; this.pos=pos; this.color=color; } }
    class StepOp { constructor(src,dst){ this.src=src; this.dst=dst; } toString(){ return `${this.src+1} -> ${this.dst+1}`; } }
    class UndoOp { toString(){ return 'Undo'; } }

    class Game {
      constructor(groups, undoCount=5, capacity=null, mode=GameMode.NORMAL){
        if(capacity==null){ const set=new Set(groups.map(g=>g.length)); if(set.size!==1) throw new Error('All groups should have same length!'); capacity=[...set][0]; }
        this.capacity=capacity; this.groups=groups.map(g=>Game.normalizeGroup(g)); this.undoCount=undoCount; this.mode=mode;
        this.prev=null; this.allRevealed=new Set(); this.revealedNew=false;
        this.containsUnknown=this.groups.some(g=> g.some(n=> n.type===NodeType.UNKNOWN || n.type===NodeType.UNK_REVEALED));
      }
      static normalizeGroup(g){ const t=[...g]; while(t.length && t[t.length-1].type===NodeType.EMPTY) t.pop(); return t; }
      isGroupCompleted(g){ if(g.length!==this.capacity) return false; if(g.some(n=>n.type!==NodeType.KNOWN)) return false; const f=JSON.stringify(g[0].color); return g.every(n=> JSON.stringify(n.color)===f); }
      ops(){ const res=[], avail=[]; let seenEmpty=false; for(let i=0;i<this.groups.length;i++){ const g=this.groups[i]; if(g.length<this.capacity){ if(g.length===0){ if(seenEmpty) continue; seenEmpty=true; } avail.push(i); } }
        for(let s=0;s<this.groups.length;s++){ const src=this.groups[s]; if(!src.length) continue; if(this.isGroupCompleted(src)) continue; const opItem=(this.mode===GameMode.QUEUE)?src[0]:src[src.length-1]; const tmp=[]; for(const d of avail){ if(d===s) continue; const dst=this.groups[d]; if(opItem.type===NodeType.KNOWN && new Set(src.map(n=> JSON.stringify(n.color))).size===1 && dst.length===0) continue; if(opItem.type===NodeType.KNOWN && dst.length>0 && dst[dst.length-1].type===NodeType.KNOWN && JSON.stringify(dst[dst.length-1].color)===JSON.stringify(opItem.color) && new Set(dst.map(n=> JSON.stringify(n.color))).size===1){ tmp.splice(0,tmp.length,new StepOp(s,d)); break; } if(dst.length===0){ tmp.push(new StepOp(s,d)); continue; } if(dst[dst.length-1].type===NodeType.KNOWN && JSON.stringify(dst[dst.length-1].color)===JSON.stringify(opItem.color)){ tmp.push(new StepOp(s,d)); continue; } } res.push(...tmp); }
        if(this.containsUnknown && this.prev && this.undoCount>0) res.push(new UndoOp()); return res; }
      apply(op){ if(op instanceof UndoOp){ if(!this.prev) return this; const ng=this.prev.clone(); ng.undoCount=this.undoCount-1; for(const g of ng.groups){ for(let i=0;i<g.length;i++){ const n=g[i]; const key=`${n.pos[0]},${n.pos[1]}`; if(this.allRevealed.has(key)) g[i]=new GameNode(NodeType.UNK_REVEALED,[...n.pos]); } } return ng; }
        if(!(op instanceof StepOp)) return this; const ns=this.clone(); const src=ns.groups[op.src], dst=ns.groups[op.dst]; const cap=ns.capacity; const pickFromTop=(ns.mode!==GameMode.QUEUE); const pickIndex=pickFromTop?src.length-1:0; const item=src[pickIndex]; let revealFlag=null; if(item.type===NodeType.UNK_REVEALED){ dst.push(src.splice(pickIndex,1)[0]); } else if(item.type===NodeType.KNOWN){ if(ns.mode===GameMode.NO_COMBO){ if(dst.length<cap) dst.push(src.splice(pickIndex,1)[0]); } else if(ns.mode===GameMode.NORMAL){ const key=JSON.stringify(item.color); while(src.length && src[src.length-1].type===NodeType.KNOWN && JSON.stringify(src[src.length-1].color)===key && dst.length<cap){ dst.push(src.pop()); } } else if(ns.mode===GameMode.QUEUE){ const key=JSON.stringify(item.color); while(src.length && src[0].type===NodeType.KNOWN && JSON.stringify(src[0].color)===key && dst.length<cap){ dst.push(src.shift()); } } }
        if(src.length && src[src.length-1].type===NodeType.UNKNOWN){ const top=src[src.length-1]; revealFlag=`${top.pos[0]},${top.pos[1]}`; src[src.length-1]=new GameNode(NodeType.UNK_REVEALED,[...top.pos]); }
        const next=new Game(ns.groups.map(g=>g.map(n=>n)), ns.undoCount, ns.capacity, ns.mode); next.prev=this; next.allRevealed=new Set(this.allRevealed); if(revealFlag){ next.allRevealed.add(revealFlag); next.revealedNew=true; } return next; }
      clone(){ const gs=this.groups.map(g=> g.map(n=> new GameNode(n.type,[...n.pos], n.color?[...n.color]:null))); const c=new Game(gs,this.undoCount,this.capacity,this.mode); c.prev=this.prev; c.allRevealed=new Set(this.allRevealed); c.revealedNew=this.revealedNew; return c; }
      get winning(){ return this.groups.every(g=> !g.length || this.isGroupCompleted(g)); }
      get unknownRevealedCount(){ return this.groups.reduce((a,g)=> a+g.filter(n=> n.type===NodeType.UNK_REVEALED).length,0); }
      get segments(){ let seg=0; for(const g of this.groups){ let last=null; for(let i=0;i<g.length;i++){ const n=g[i]; if(i===0) seg++; else { if(n.type!==last.type) seg++; else if(n.type===NodeType.UNKNOWN || n.type===NodeType.UNK_REVEALED) seg++; else if(JSON.stringify(n.color)!==JSON.stringify(last.color)) seg++; } last=n; } } return seg; }
      get completedGroupCount(){ return this.groups.filter(g=> this.isGroupCompleted(g)).length; }
      get heuristic(){ return [this.segments, this.completedGroupCount]; }
      key(){ return JSON.stringify({g:this.groups.map(g=> g.map(n=> ({t:n.type,c:n.color}))), u:this.undoCount, m:this.mode}); }
    }

    // ----------------- UI (grid editor) -----------------
    const grid = document.getElementById('grid');
    const ctx = grid.getContext('2d');
    const colsEl = document.getElementById('cols');
    const rowsEl = document.getElementById('rows');
    const cellSizeEl = document.getElementById('cellsize');
    const modeEl = document.getElementById('mode');
    const stepsEl = document.getElementById('steps');
    const statusEl = document.getElementById('status');
    const undoEl = document.getElementById('undo');
    const paletteEl = document.getElementById('palette');
    const numColorsEl = document.getElementById('numcolors');

    let W=+colsEl.value, H=+rowsEl.value, S=+cellSizeEl.value;
    let board = createBoard(W,H);

    // Palette state: [{rgb:[r,g,b], target:H, remaining:H}]
    let palette = [];
    let activeColorIndex = 0;

    function createBoard(w,h){ return Array.from({length:w},()=> Array.from({length:h},()=>({type:NodeType.EMPTY, color:null}))); }
    function hexToRgb(hex){ const h=hex.replace('#',''); return [parseInt(h.slice(0,2),16), parseInt(h.slice(2,4),16), parseInt(h.slice(4,6),16)]; }
    function rgbToHex([r,g,b]){ return '#'+[r,g,b].map(x=> x.toString(16).padStart(2,'0')).join(''); }

    function rebuildPalette(){
      const n = Math.max(1, Math.min(20, +numColorsEl.value || Math.max(2, W-2)));
      const base = [ '#ef4444','#f59e0b','#10b981','#3b82f6','#8b5cf6','#ec4899','#22c55e','#eab308','#06b6d4','#f97316','#84cc16','#a3e635','#14b8a6','#6366f1','#f43f5e','#06b6d4','#facc15','#22d3ee','#16a34a','#8b5cf6' ];
      palette = Array.from({length:n},(_,i)=>({ rgb: hexToRgb(base[i%base.length]), target: H, remaining: H }));
      // recompute remaining based on current board placements
      recalcPaletteRemaining();
      renderPalette();
    }

    function recalcPaletteRemaining(){
      for(const p of palette){ p.remaining = p.target; }
      for(let c=0;c<W;c++) for(let r=0;r<H;r++){
        const cell=board[c][r];
        if(cell.type===NodeType.KNOWN && cell.color){
          const idx = palette.findIndex(p=> JSON.stringify(p.rgb)===JSON.stringify(cell.color));
          if(idx>=0) palette[idx].remaining = Math.max(0, palette[idx].remaining-1);
        }
      }
    }

    function renderPalette(){
      paletteEl.innerHTML='';
      palette.forEach((p,idx)=>{
        const sw=document.createElement('div'); sw.className='swatch'+(idx===activeColorIndex?' active':''); sw.style.background=rgbToHex(p.rgb);
        const badge=document.createElement('span'); badge.className='badge'; badge.textContent=p.remaining; sw.appendChild(badge);
        sw.onclick=()=>{ activeColorIndex=idx; renderPalette(); };
        paletteEl.appendChild(sw);
      });
    }

    function resize(){
      W = Math.max(2, Math.min(24, +colsEl.value||14));
      H = Math.max(2, Math.min(12, +rowsEl.value||4));
      S = Math.max(16, Math.min(48, +cellSizeEl.value||36));
      grid.width = W*S; grid.height = H*S;
      if(board.length!==W || board[0].length!==H) board=createBoard(W,H);
      // Update palette targets to new H, keep colors
      palette.forEach(p=>{ p.target = H; });
      recalcPaletteRemaining();
      renderPalette();
      draw();
    }

    function draw(){
      ctx.clearRect(0,0,grid.width,grid.height);
      for(let c=0;c<W;c++){
        for(let r=0;r<H;r++){
          const y=(H-1-r)*S, x=c*S, cell=board[c][r];
          if(cell.type===NodeType.EMPTY){ ctx.fillStyle='#ffffff'; }
          else { const [R,G,B]=cell.color; ctx.fillStyle=`rgb(${R},${G},${B})`; }
          ctx.fillRect(x,y,S,S);
          ctx.strokeStyle='rgba(255,255,255,.08)'; ctx.strokeRect(x+.5,y+.5,S-1,S-1);
        }
      }
    }

    grid.addEventListener('contextmenu', e=> e.preventDefault());
    grid.addEventListener('mousedown', e=>{
      const rect = grid.getBoundingClientRect();
      const cx = Math.floor((e.clientX-rect.left)/S);
      const cy = H-1-Math.floor((e.clientY-rect.top)/S);
      if(cx<0||cy<0||cx>=W||cy>=H) return;

      const cell = board[cx][cy];
      if(e.button===2){ // erase
        if(cell.type!==NodeType.EMPTY){
          // refund remaining to matching palette color
          const idx = palette.findIndex(p=> JSON.stringify(p.rgb)===JSON.stringify(cell.color));
          if(idx>=0) palette[idx].remaining = Math.min(palette[idx].target, palette[idx].remaining+1);
        }
        board[cx][cy] = {type:NodeType.EMPTY, color:null};
      } else { // left click: paint with active color
        const p = palette[activeColorIndex]; if(!p) return;
        if(p.remaining<=0){ stepsEl.textContent='Palette empty for this color.'; return; }
        // if replacing an existing known color, refund its palette first
        if(cell.type!==NodeType.EMPTY){
          const idx = palette.findIndex(pp=> JSON.stringify(pp.rgb)===JSON.stringify(cell.color));
          if(idx>=0) palette[idx].remaining = Math.min(palette[idx].target, palette[idx].remaining+1);
        }
        board[cx][cy] = {type:NodeType.KNOWN, color:[...p.rgb]};
        p.remaining -= 1;
      }
      renderPalette();
      draw();
    });

    document.getElementById('reset').onclick = ()=>{ board=createBoard(W,H); recalcPaletteRemaining(); renderPalette(); draw(); stepsEl.textContent=''; };
    document.getElementById('rand').onclick = ()=>{
      // Typical setup: fill N-2 tubes with H of each color
      const n = Math.max(1, Math.min(W-2, palette.length||Math.max(2,W-2)));
      if(!palette.length) rebuildPalette();
      board=createBoard(W,H);
      for(let t=0;t<n;t++){
        for(let r=0;r<H;r++) board[t][r] = {type:NodeType.KNOWN, color:[...palette[t].rgb]};
      }
      // shuffle
      for(let k=0;k<200;k++){
        const a=Math.floor(Math.random()*W), b=Math.floor(Math.random()*W);
        if(a===b) continue;
        const srcTop = board[a].slice().reverse().findIndex(c=>c.type!==NodeType.EMPTY); if(srcTop<0) continue; const ai=board[a].length-1-srcTop;
        const bi = board[b].slice().reverse().findIndex(c=>c.type!==NodeType.EMPTY); const insert = bi<0?0:board[b].length-1-bi+1;
        const cell = board[a][ai];
        for(let r=board[a].length-1;r>ai;r--) board[a][r]=board[a][r-1]; board[a][ai]={type:NodeType.EMPTY, color:null};
        for(let r=board[b].length-1;r>insert;r--) board[b][r]=board[b][r-1]; board[b][insert]=cell;
      }
      recalcPaletteRemaining();
      renderPalette();
      draw();
    };

    document.getElementById('rebuildPalette').onclick = rebuildPalette;

    colsEl.oninput = rowsEl.oninput = cellSizeEl.oninput = resize;
    // initial palette build
    rebuildPalette();
    resize();

    // ----------------- Solver wiring -----------------
    let cachedSteps=[];
    function buildGameFromBoard(board, capacity, mode, undo){
      const groups=[]; for(let c=0;c<board.length;c++){ const g=[]; for(let r=0;r<board[0].length;r++){ const cell=board[c][r]; if(cell.type===NodeType.EMPTY) g.push(new GameNode(NodeType.EMPTY,[c,r])); else g.push(new GameNode(NodeType.KNOWN,[c,r],[...cell.color])); } groups.push(g);} return new Game(groups, undo, capacity, mode);
    }

    document.getElementById('solve').onclick = ()=>{
      try{ stepsEl.textContent='Solving…'; const g=buildGameFromBoard(board,H,+modeEl.value,+undoEl.value); const res=solve(g); cachedSteps=res.path.map(op=>op.toString()); stepsEl.textContent=cachedSteps.length?cachedSteps.join('\n'):'(no moves found)'; statusEl.textContent=res.state.winning?'Solved to a winning state.':'Heuristic found a partial path.'; } catch(e){ stepsEl.textContent='Error: '+e.message; console.error(e);} };
    document.getElementById('clear').onclick = ()=>{ cachedSteps=[]; stepsEl.textContent=''; };
    document.getElementById('step').onclick = ()=>{
      if(!cachedSteps.length){ stepsEl.textContent='(no steps cached — hit Solve first)'; return; }
      const instr=cachedSteps.shift(); stepsEl.textContent=[instr,...cachedSteps].join('\n'); if(!instr||instr==='Undo') return; const [a,b]=instr.split(' -> ').map(x=>parseInt(x,10)-1);
      const src=board[a], dst=board[b]; if(!src||!dst) return; let idx=src.slice().reverse().findIndex(c=>c.type!==NodeType.EMPTY); if(idx<0) return; idx=src.length-1-idx; const top=src[idx]; const cap=H; const key=JSON.stringify(top.color||null);
      while(idx>=0 && src[idx].type===NodeType.KNOWN && JSON.stringify(src[idx].color||null)===key && dst.filter(c=>c.type!==NodeType.EMPTY).length<cap){ const dstTopIdx=dst.slice().reverse().findIndex(c=>c.type!==NodeType.EMPTY); const insertAt=dstTopIdx<0?0:dst.length-1-dstTopIdx+1; for(let r=dst.length-1;r>insertAt;r--) dst[r]=dst[r-1]; dst[insertAt]=src[idx]; src[idx]={type:NodeType.EMPTY,color:null}; idx--; }
      draw();
    };

    // ----------------- Self-tests -----------------
    document.getElementById('runtests').onclick = ()=>{
      const out=[]; let pass=0,fail=0; function expect(name,cond){ if(cond){ out.push('✅ '+name); pass++; } else { out.push('❌ '+name); fail++; } }
      // Test 1: palette rebuild sets remaining to H
      const oldH=H; H=4; rebuildPalette(); expect('Palette targets equal H', palette.every(p=> p.target===4 && p.remaining===4));
      // Test 2: painting decrements, erasing refunds
      const p0Before=palette[0].remaining; board[0][0]={type:NodeType.EMPTY,color:null}; grid.dispatchEvent(new MouseEvent('mousedown',{clientX:1,clientY:grid.getBoundingClientRect().bottom-1,bubbles:true})); expect('Painting used 1 piece', palette[0].remaining===p0Before-1);
      grid.dispatchEvent(new MouseEvent('mousedown',{clientX:1,clientY:grid.getBoundingClientRect().bottom-1,button:2,bubbles:true})); expect('Erasing refunded 1 piece', palette[0].remaining===p0Before);
      // Test 3: solver still returns something on trivial board
      const g=buildGameFromBoard(createBoard(2,4),4,GameMode.NORMAL,5); const res=solve(g); expect('Solver returns state', !!res);
      out.push(`\n${pass} passed, ${fail} failed.`); stepsEl.textContent=out.join('\n'); statusEl.textContent=fail===0?'All tests passed.':'Some tests failed — see log.'; H=oldH; resize(); };
  </script>
</body>
</html>
